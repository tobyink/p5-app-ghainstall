#!perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/GhaInstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_GHAINSTALL';
  use 5.006;
  use strict;
  use warnings;
  
  package App::GhaInstall;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '0.001';
  
  our $ALLOW_FAIL = 0;
  our $DRY_RUN    = 0;
  
  sub maybe_die {
  	my $exit = shift;
  	if ( $exit ) {
  		if ( $ALLOW_FAIL ) {
  			warn "Failed, but continuing anyway...\n";
  		}
  		else {
  			die "Failed; stopping!\n";
  		}
  	}
  	return;
  }
  
  sub CPAN_CONFIG_FILENAME () {
  	$ENV{HOME} . '/' . 'GhaInstallConfig.pm'
  }
  
  sub SHOULD_INSTALL_OPTIONAL_DEPS () {
  	no warnings;
  	$ENV{GHA_TESTING_COVER} =~ /^(true|1)$/i
  	or $ENV{GHA_INSTALL_OPTIONAL} =~ /^(true|1)$/i
  }
  
  sub go {
  	shift;
  	
  	my @modules;
  	
  	foreach ( @_ ) {
  		if ( /--allow-fail/ ) {
  			$ALLOW_FAIL = 1;
  		}
  		elsif ( /--dry-run/ ) {
  			$DRY_RUN = 1;
  		}
  		elsif ( /--configure/ ) {
  			install_configure_dependencies();
  		}
  		elsif ( /--auto/ ) {
  			install_dependencies();
  		}
  		else {
  			push @modules, $_;
  		}
  	}
  	
  	if ( @modules ) {
  		install_modules( @modules );
  	}
  	
  	return 0;
  }
  
  sub slurp {
  	my $file = shift;
  	open my $fh, '<', $file
  		or die "$file exists but cannot be read\n";
  	local $/;
  	return <$fh>;
  }
  
  sub read_json {
  	my $file = shift;
  	return unless -f $file;
  	
  	my $hash;
  	
  	if ( eval { require JSON::MaybeXS; 1 } ) {
  		my $json = 'JSON::MaybeXS'->new;
  		$hash = $json->decode( slurp($file) );
  	}
  	elsif ( eval { require JSON::PP; 1 } ) {
  		my $json = 'JSON::PP'->new;
  		$hash = $json->decode( slurp($file) );
  	}
  	else {
  		# Bundled version of JSON::Tiny
  		require App::GhaInstall::JSON;
  		$hash = JSON::Tiny::decode_json( slurp($file) );
  	}
  	
  	return unless ref($hash) eq 'HASH';
  	
  	$hash->{metatype} = 'JSON';
  	return $hash;
  }
  
  sub read_yaml {
  	my $file = shift;
  	return unless -f $file;
  	
  	my $hash;
  	
  	if ( eval { require JSON::XS; 1 } ) {
  		$hash = YAML::XS::Load( slurp($file) );
  	}
  	else {
  		# Bundled version of YAML::Tiny
  		require App::GhaInstall::YAML;
  		$hash = YAML::Tiny::Load( slurp($file) );		
  	}
  	
  	return unless ref($hash) eq 'HASH';
  	
  	$hash->{metatype} = 'YAML';
  	return $hash;
  }
  
  sub install_configure_dependencies {
  	my $meta =
  		read_json('META.json') || read_yaml('META.yml')
  		or die("Cannot read META.json or META.yml");
  	
  	my ( @need, @want );
  	
  	if ( $meta->{metatype} eq 'JSON' ) {
  		for my $phase ( qw( configure build ) ) {
  			push @need, keys %{ $meta->{prereqs}{$phase}{requires}   or {} };
  			push @want, keys %{ $meta->{prereqs}{$phase}{recommends} or {} };
  			push @want, keys %{ $meta->{prereqs}{$phase}{suggests}   or {} };
  		}
  	}
  	else {
  		push @need, keys %{ $meta->{configure_requires} or {} };
  		push @need, keys %{ $meta->{build_requires}     or {} };
  	}
  	
  	if ( @need ) {
  		install_modules( @need );
  	}
  	
  	if ( @want and SHOULD_INSTALL_OPTIONAL_DEPS ) {
  		local $ALLOW_FAIL = 1;
  		install_modules( @want );
  	}
  	
  	return;
  }
  
  sub install_dependencies {
  	my $meta =
  		read_json('MYMETA.json') || read_yaml('MYMETA.yml') || read_json('META.json') || read_yaml('META.yml')
  		or die("Cannot read MYMETA.json or MYMETA.yml");
  	
  	my ( @need, @want );
  	
  	if ( $meta->{metatype} eq 'JSON' ) {
  		for my $phase ( qw( configure build runtime test ) ) {
  			push @need, keys %{ $meta->{prereqs}{$phase}{requires}   or {} };
  			push @want, keys %{ $meta->{prereqs}{$phase}{recommends} or {} };
  			push @want, keys %{ $meta->{prereqs}{$phase}{suggests}   or {} };
  		}
  	}
  	else {
  		push @need, keys %{ $meta->{configure_requires} or {} };
  		push @need, keys %{ $meta->{build_requires}     or {} };
  		push @need, keys %{ $meta->{requires}           or {} };
  		push @need, keys %{ $meta->{test_requires}      or {} };
  		push @want, keys %{ $meta->{recommends}         or {} };
  	}
  	
  	push @need, 'App::GhaProve';
  	
  	if ( @need ) {
  		install_modules( @need );
  	}
  	
  	if ( @want and SHOULD_INSTALL_OPTIONAL_DEPS ) {
  		local $ALLOW_FAIL = 1;
  		install_modules( @want );
  	}
  	
  	return;
  }
  
  my $installer;
  sub INSTALLER () {
  	return $installer if defined $installer;
  	my $output = `cpanm --version`;
  	if ( $output =~ /cpanminus/ ) {
  		$installer = 'cpanm';
  	}
  	else {
  		$output = `cpm --help`;
  		if ( $output =~ /install/ ) {
  			$installer = 'cpm';
  		}
  		else {
  			ensure_configured_cpan();
  			$installer = 'cpan';
  		}
  	}
  	return $installer;
  }
  
  sub install_modules {
  	my @modules = grep $_ ne 'perl', @_;
  	
  	if ( $DRY_RUN ) {
  		warn "install: $_\n" for @modules;
  		return;
  	}
  
  	if ( INSTALLER eq 'cpanm' ) {
  		return maybe_die system 'cpanm', '-n', @modules;
  	}
  	
  	if ( INSTALLER eq 'cpm' ) {
  		return maybe_die system 'cpm', 'install', '-g', @modules;
  	}
  
  	install_module $_ for @_;
  }
  
  sub install_module {
  	my $module = shift;
  	
  	if ( $DRY_RUN ) {
  		warn "install: $module\n";
  		return;
  	}
  	
  	if ( INSTALLER eq 'cpanm' ) {
  		return maybe_die system 'cpanm', '-n', $module;
  	}
  	
  	if ( INSTALLER eq 'cpm' ) {
  		return maybe_die system 'cpm', 'install', '-g', $module;
  	}
  	
  	return maybe_die system 'cpan', '-J', CPAN_CONFIG_FILENAME, '-T', $module;
  }
  
  sub ensure_configured_cpan {
  	return if -f CPAN_CONFIG_FILENAME;
  	open my $fh, '>', CPAN_CONFIG_FILENAME; print { $fh } <<'CONFIG';
  use Cwd ();
  
  my $home = $ENV{HOME};
  my $cwd  = Cwd::cwd;
  
  $CPAN::Config = {
    'applypatch' => q[],
    'auto_commit' => q[0],
    'build_cache' => q[100],
    'build_dir' => qq[$home/.cpan/build],
    'build_dir_reuse' => q[0],
    'build_requires_install_policy' => q[yes],
    'bzip2' => q[/bin/bzip2],
    'cache_metadata' => q[1],
    'check_sigs' => q[0],
    'colorize_output' => q[0],
    'commandnumber_in_prompt' => q[1],
    'connect_to_internet_ok' => q[1],
    'cpan_home' => qq[$home/.cpan],
    'ftp_passive' => q[1],
    'ftp_proxy' => q[],
    'getcwd' => q[cwd],
    'gpg' => q[/usr/bin/gpg],
    'gzip' => q[/bin/gzip],
    'halt_on_failure' => q[0],
    'histfile' => qq[$home/.cpan/histfile],
    'histsize' => q[100],
    'http_proxy' => q[],
    'inactivity_timeout' => q[0],
    'index_expire' => q[1],
    'inhibit_startup_message' => q[0],
    'keep_source_where' => qq[$home/.cpan/sources],
    'load_module_verbosity' => q[none],
    'make' => q[/usr/bin/make],
    'make_arg' => q[],
    'make_install_arg' => q[],
    'make_install_make_command' => q[/usr/bin/make],
    'makepl_arg' => q[INSTALLDIRS=site],
    'mbuild_arg' => q[],
    'mbuild_install_arg' => q[],
    'mbuild_install_build_command' => q[./Build],
    'mbuildpl_arg' => q[--installdirs site],
    'no_proxy' => q[],
    'pager' => q[/usr/bin/less],
    'patch' => q[/usr/bin/patch],
    'perl5lib_verbosity' => q[none],
    'prefer_external_tar' => q[1],
    'prefer_installer' => q[MB],
    'prefs_dir' => qq[$home/.cpan/prefs],
    'prerequisites_policy' => q[follow],
    'scan_cache' => q[atstart],
    'shell' => q[/bin/sh],
    'show_unparsable_versions' => q[0],
    'show_upload_date' => q[0],
    'show_zero_versions' => q[0],
    'tar' => q[/bin/tar],
    'tar_verbosity' => q[none],
    'term_is_latin' => q[1],
    'term_ornaments' => q[1],
    'test_report' => q[0],
    'trust_test_report_history' => q[0],
    'unzip' => q[/usr/bin/unzip],
    'urllist' => [q[http://cpan.mirrors.uk2.net/], q[http://cpan.singletasker.co.uk/], q[http://cpan.cpantesters.org/]],
    'use_sqlite' => q[0],
    'version_timeout' => q[15],
    'wget' => q[/usr/bin/wget],
    'yaml_load_code' => q[0],
    'yaml_module' => q[YAML],
  };
  1;
  CONFIG
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  App::GhaInstall - provides the gha-install command
  
  =head1 SYNOPSIS
  
  Install dependencies for a distribution, assuming you're in the distro's
  root directory (where Makefile.PL and META.json live):
  
    $ gha-install --configure
    $ perl Makefile.PL
    $ gha-install --auto
  
  Install things by name:
  
    $ gha-install HTTP::Tiny
  
  Install things by name, but ignore failures:
  
    $ gha-install --allow-fail HTTP::Tiny
  
  =head1 DESCRIPTION
  
  This is a wrapper around L<App::cpanminus>, L<App::cpm>, or L<CPAN>,
  depending on what is available. Mostly because L<App::cpanminus>
  doesn't work on Perl 5.6.
  
  Copies of L<YAML::Tiny> and L<JSON::Tiny> are bundled, just in case.
  
  C<< gha-install >> is intended to be packable with L<App::FatPacker>.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=App-GhaInstall>.
  
  =head1 SEE ALSO
  
  L<App::cpanminus>, L<App::cpm>, L<CPAN>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2020 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
APP_GHAINSTALL

$fatpacked{"App/GhaInstall/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_GHAINSTALL_JSON';
  package JSON::Tiny;
  
  # Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
  # License: Artistic 2.0 license.
  # http://www.perlfoundation.org/artistic_license_2_0
  
  use strict;
  use warnings;
  use base 'Exporter';
  use Carp 'croak';
  use Scalar::Util 'blessed';
  use Encode ();
  use B;
  
  our $VERSION = '0.58';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Literal names
  # Users may override Booleans with literal 0 or 1 if desired.
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  
  # Escaped special character map with u2028 and u2029
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {$FALSE}  ## no critic (prototypes)
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {$TRUE} ## no critic (prototypes)
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length( local $_ = shift );
  
      # UTF-8
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
    
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos $str, length $str;
  }
  
  sub _decode_value {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if m/\G"/gc;
  
    # Object
    return _decode_object() if m/\G\{/gc;
  
    # Array
    return _decode_array() if m/\G\[/gc;
  
    # Number
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
  
    # True
    return $TRUE if m/\Gtrue/gc;
  
    # False
    return $FALSE if m/\Gfalse/gc;
  
    # Null
    return undef if m/\Gnull/gc;  ## no critic (return)
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
  
      # Blessed reference with TO_JSON method
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
  
    # Null
    return 'null' unless defined $value;
  
  
    # Number (bitwise operators change behavior based on the internal value type)
  
    return $value
      if B::svref_2object(\$value)->FLAGS & (B::SVp_IOK | B::SVp_NOK)
      # filter out "upgraded" strings whose numeric form doesn't strictly match
      && 0 + $value eq $value
      # filter out inf and nan
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  # Emulate boolean type
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
APP_GHAINSTALL_JSON

$fatpacked{"App/GhaInstall/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_GHAINSTALL_YAML';
  package YAML::Tiny;
  BEGIN {
    $YAML::Tiny::AUTHORITY = 'cpan:ADAMK';
  }
  {
    $YAML::Tiny::VERSION = '1.56';
  }
  # git description: v1.55-3-gc945058
  
  
  use strict;
  use warnings;
  
  # UTF Support?
  sub HAVE_UTF8 () { $] >= 5.007003 }
  BEGIN {
      if ( HAVE_UTF8 ) {
          # The string eval helps hide this from Test::MinimumVersion
          eval "require utf8;";
          die "Failed to load UTF-8 support" if $@;
      }
  
      # Class structure
      require 5.004;
      require Exporter;
      require Carp;
      @YAML::Tiny::ISA       = qw{ Exporter  };
      @YAML::Tiny::EXPORT    = qw{ Load Dump };
      @YAML::Tiny::EXPORT_OK = qw{ LoadFile DumpFile freeze thaw };
  
      # Error storage
      $YAML::Tiny::errstr    = '';
  }
  
  # The character class of all characters we need to escape
  # NOTE: Inlined, since it's only used once
  # my $RE_ESCAPE = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f\"\n]';
  
  # Printed form of the unprintable characters in the lowest range
  # of ASCII characters, listed by ASCII ordinal position.
  my @UNPRINTABLE = qw(
      z    x01  x02  x03  x04  x05  x06  a
      x08  t    n    v    f    r    x0e  x0f
      x10  x11  x12  x13  x14  x15  x16  x17
      x18  x19  x1a  e    x1c  x1d  x1e  x1f
  );
  
  # Printable characters for escapes
  my %UNESCAPES = (
      z => "\x00", a => "\x07", t    => "\x09",
      n => "\x0a", v => "\x0b", f    => "\x0c",
      r => "\x0d", e => "\x1b", '\\' => '\\',
  );
  
  # Special magic boolean words
  my %QUOTE = map { $_ => 1 } qw{
      null Null NULL
      y Y yes Yes YES n N no No NO
      true True TRUE false False FALSE
      on On ON off Off OFF
  };
  
  
  
  
  
  #####################################################################
  # Implementation
  
  # Create an empty YAML::Tiny object
  sub new {
      my $class = shift;
      bless [ @_ ], $class;
  }
  
  # Create an object from a file
  sub read {
      my $class = ref $_[0] ? ref shift : shift;
  
      # Check the file
      my $file = shift or return $class->_error( 'You did not specify a file name' );
      return $class->_error( "File '$file' does not exist" )              unless -e $file;
      return $class->_error( "'$file' is a directory, not a file" )       unless -f _;
      return $class->_error( "Insufficient permissions to read '$file'" ) unless -r _;
  
      # Slurp in the file
      local $/ = undef;
      local *CFG;
      unless ( open(CFG, $file) ) {
          return $class->_error("Failed to open file '$file': $!");
      }
      my $contents = <CFG>;
      unless ( close(CFG) ) {
          return $class->_error("Failed to close file '$file': $!");
      }
  
      $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
      my $class  = ref $_[0] ? ref shift : shift;
      my $self   = bless [], $class;
      my $string = $_[0];
      eval {
          unless ( defined $string ) {
              die \"Did not provide a string to load";
          }
  
          # Byte order marks
          # NOTE: Keeping this here to educate maintainers
          # my %BOM = (
          #     "\357\273\277" => 'UTF-8',
          #     "\376\377"     => 'UTF-16BE',
          #     "\377\376"     => 'UTF-16LE',
          #     "\377\376\0\0" => 'UTF-32LE'
          #     "\0\0\376\377" => 'UTF-32BE',
          # );
          if ( $string =~ /^(?:\376\377|\377\376|\377\376\0\0|\0\0\376\377)/ ) {
              die \"Stream has a non UTF-8 BOM";
          } else {
              # Strip UTF-8 bom if found, we'll just ignore it
              $string =~ s/^\357\273\277//;
          }
  
          # Try to decode as utf8
          utf8::decode($string) if HAVE_UTF8;
  
          # Check for some special cases
          return $self unless length $string;
          unless ( $string =~ /[\012\015]+\z/ ) {
              die \"Stream does not end with newline character";
          }
  
          # Split the file into lines
          my @lines = grep { ! /^\s*(?:\#.*)?\z/ }
                  split /(?:\015{1,2}\012|\015|\012)/, $string;
  
          # Strip the initial YAML header
          @lines and $lines[0] =~ /^\%YAML[: ][\d\.]+.*\z/ and shift @lines;
  
          # A nibbling parser
          while ( @lines ) {
              # Do we have a document header?
              if ( $lines[0] =~ /^---\s*(?:(.+)\s*)?\z/ ) {
                  # Handle scalar documents
                  shift @lines;
                  if ( defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/ ) {
                      push @$self, $self->_read_scalar( "$1", [ undef ], \@lines );
                      next;
                  }
              }
  
              if ( ! @lines or $lines[0] =~ /^(?:---|\.\.\.)/ ) {
                  # A naked document
                  push @$self, undef;
                  while ( @lines and $lines[0] !~ /^---/ ) {
                      shift @lines;
                  }
  
              } elsif ( $lines[0] =~ /^\s*\-/ ) {
                  # An array at the root
                  my $document = [ ];
                  push @$self, $document;
                  $self->_read_array( $document, [ 0 ], \@lines );
  
              } elsif ( $lines[0] =~ /^(\s*)\S/ ) {
                  # A hash at the root
                  my $document = { };
                  push @$self, $document;
                  $self->_read_hash( $document, [ length($1) ], \@lines );
  
              } else {
                  die \"YAML::Tiny failed to classify the line '$lines[0]'";
              }
          }
      };
      if ( ref $@ eq 'SCALAR' ) {
          return $self->_error(${$@});
      } elsif ( $@ ) {
          require Carp;
          Carp::croak($@);
      }
  
      return $self;
  }
  
  # Deparse a scalar string to the actual scalar
  sub _read_scalar {
      my ($self, $string, $indent, $lines) = @_;
  
      # Trim trailing whitespace
      $string =~ s/\s*\z//;
  
      # Explitic null/undef
      return undef if $string eq '~';
  
      # Single quote
      if ( $string =~ /^\'(.*?)\'(?:\s+\#.*)?\z/ ) {
          return '' unless defined $1;
          $string = $1;
          $string =~ s/\'\'/\'/g;
          return $string;
      }
  
      # Double quote.
      # The commented out form is simpler, but overloaded the Perl regex
      # engine due to recursion and backtracking problems on strings
      # larger than 32,000ish characters. Keep it for reference purposes.
      # if ( $string =~ /^\"((?:\\.|[^\"])*)\"\z/ ) {
      if ( $string =~ /^\"([^\\"]*(?:\\.[^\\"]*)*)\"(?:\s+\#.*)?\z/ ) {
          # Reusing the variable is a little ugly,
          # but avoids a new variable and a string copy.
          $string = $1;
          $string =~ s/\\"/"/g;
          $string =~ s/\\([never\\fartz]|x([0-9a-fA-F]{2}))/(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}/gex;
          return $string;
      }
  
      # Special cases
      if ( $string =~ /^[\'\"!&]/ ) {
          die \"YAML::Tiny does not support a feature in line '$string'";
      }
      return {} if $string =~ /^{}(?:\s+\#.*)?\z/;
      return [] if $string =~ /^\[\](?:\s+\#.*)?\z/;
  
      # Regular unquoted string
      if ( $string !~ /^[>|]/ ) {
          if (
              $string =~ /^(?:-(?:\s|$)|[\@\%\`])/
              or
              $string =~ /:(?:\s|$)/
          ) {
              die \"YAML::Tiny found illegal characters in plain scalar: '$string'";
          }
          $string =~ s/\s+#.*\z//;
          return $string;
      }
  
      # Error
      die \"YAML::Tiny failed to find multi-line scalar content" unless @$lines;
  
      # Check the indent depth
      $lines->[0]   =~ /^(\s*)/;
      $indent->[-1] = length("$1");
      if ( defined $indent->[-2] and $indent->[-1] <= $indent->[-2] ) {
          die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
      }
  
      # Pull the lines
      my @multiline = ();
      while ( @$lines ) {
          $lines->[0] =~ /^(\s*)/;
          last unless length($1) >= $indent->[-1];
          push @multiline, substr(shift(@$lines), length($1));
      }
  
      my $j = (substr($string, 0, 1) eq '>') ? ' ' : "\n";
      my $t = (substr($string, 1, 1) eq '-') ? ''  : "\n";
      return join( $j, @multiline ) . $t;
  }
  
  # Parse an array
  sub _read_array {
      my ($self, $array, $indent, $lines) = @_;
  
      while ( @$lines ) {
          # Check for a new document
          if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
              while ( @$lines and $lines->[0] !~ /^---/ ) {
                  shift @$lines;
              }
              return 1;
          }
  
          # Check the indent level
          $lines->[0] =~ /^(\s*)/;
          if ( length($1) < $indent->[-1] ) {
              return 1;
          } elsif ( length($1) > $indent->[-1] ) {
              die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
          }
  
          if ( $lines->[0] =~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/ ) {
              # Inline nested hash
              my $indent2 = length("$1");
              $lines->[0] =~ s/-/ /;
              push @$array, { };
              $self->_read_hash( $array->[-1], [ @$indent, $indent2 ], $lines );
  
          } elsif ( $lines->[0] =~ /^\s*\-(\s*)(.+?)\s*\z/ ) {
              # Array entry with a value
              shift @$lines;
              push @$array, $self->_read_scalar( "$2", [ @$indent, undef ], $lines );
  
          } elsif ( $lines->[0] =~ /^\s*\-\s*\z/ ) {
              shift @$lines;
              unless ( @$lines ) {
                  push @$array, undef;
                  return 1;
              }
              if ( $lines->[0] =~ /^(\s*)\-/ ) {
                  my $indent2 = length("$1");
                  if ( $indent->[-1] == $indent2 ) {
                      # Null array entry
                      push @$array, undef;
                  } else {
                      # Naked indenter
                      push @$array, [ ];
                      $self->_read_array( $array->[-1], [ @$indent, $indent2 ], $lines );
                  }
  
              } elsif ( $lines->[0] =~ /^(\s*)\S/ ) {
                  push @$array, { };
                  $self->_read_hash( $array->[-1], [ @$indent, length("$1") ], $lines );
  
              } else {
                  die \"YAML::Tiny failed to classify line '$lines->[0]'";
              }
  
          } elsif ( defined $indent->[-2] and $indent->[-1] == $indent->[-2] ) {
              # This is probably a structure like the following...
              # ---
              # foo:
              # - list
              # bar: value
              #
              # ... so lets return and let the hash parser handle it
              return 1;
  
          } else {
              die \"YAML::Tiny failed to classify line '$lines->[0]'";
          }
      }
  
      return 1;
  }
  
  # Parse an array
  sub _read_hash {
      my ($self, $hash, $indent, $lines) = @_;
  
      while ( @$lines ) {
          # Check for a new document
          if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
              while ( @$lines and $lines->[0] !~ /^---/ ) {
                  shift @$lines;
              }
              return 1;
          }
  
          # Check the indent level
          $lines->[0] =~ /^(\s*)/;
          if ( length($1) < $indent->[-1] ) {
              return 1;
          } elsif ( length($1) > $indent->[-1] ) {
              die \"YAML::Tiny found bad indenting in line '$lines->[0]'";
          }
  
          # Get the key
          unless ( $lines->[0] =~ s/^\s*([^\'\" ][^\n]*?)\s*:(\s+(?:\#.*)?|$)// ) {
              if ( $lines->[0] =~ /^\s*[?\'\"]/ ) {
                  die \"YAML::Tiny does not support a feature in line '$lines->[0]'";
              }
              die \"YAML::Tiny failed to classify line '$lines->[0]'";
          }
          my $key = $1;
  
          # Do we have a value?
          if ( length $lines->[0] ) {
              # Yes
              $hash->{$key} = $self->_read_scalar( shift(@$lines), [ @$indent, undef ], $lines );
          } else {
              # An indent
              shift @$lines;
              unless ( @$lines ) {
                  $hash->{$key} = undef;
                  return 1;
              }
              if ( $lines->[0] =~ /^(\s*)-/ ) {
                  $hash->{$key} = [];
                  $self->_read_array( $hash->{$key}, [ @$indent, length($1) ], $lines );
              } elsif ( $lines->[0] =~ /^(\s*)./ ) {
                  my $indent2 = length("$1");
                  if ( $indent->[-1] >= $indent2 ) {
                      # Null hash entry
                      $hash->{$key} = undef;
                  } else {
                      $hash->{$key} = {};
                      $self->_read_hash( $hash->{$key}, [ @$indent, length($1) ], $lines );
                  }
              }
          }
      }
  
      return 1;
  }
  
  # Save an object to a file
  sub write {
      my $self = shift;
      my $file = shift or return $self->_error('No file name provided');
  
      # Write it to the file
      open( CFG, '>' . $file ) or return $self->_error(
          "Failed to open file '$file' for writing: $!"
          );
      print CFG $self->write_string;
      close CFG;
  
      return 1;
  }
  
  # Save an object to a string
  sub write_string {
      my $self = shift;
      return '' unless @$self;
  
      # Iterate over the documents
      my $indent = 0;
      my @lines  = ();
      foreach my $cursor ( @$self ) {
          push @lines, '---';
  
          # An empty document
          if ( ! defined $cursor ) {
              # Do nothing
  
          # A scalar document
          } elsif ( ! ref $cursor ) {
              $lines[-1] .= ' ' . $self->_write_scalar( $cursor, $indent );
  
          # A list at the root
          } elsif ( ref $cursor eq 'ARRAY' ) {
              unless ( @$cursor ) {
                  $lines[-1] .= ' []';
                  next;
              }
              push @lines, $self->_write_array( $cursor, $indent, {} );
  
          # A hash at the root
          } elsif ( ref $cursor eq 'HASH' ) {
              unless ( %$cursor ) {
                  $lines[-1] .= ' {}';
                  next;
              }
              push @lines, $self->_write_hash( $cursor, $indent, {} );
  
          } else {
              Carp::croak("Cannot serialize " . ref($cursor));
          }
      }
  
      join '', map { "$_\n" } @lines;
  }
  
  sub _write_scalar {
      my $string = $_[1];
      return '~'  unless defined $string;
      return "''" unless length  $string;
      if ( $string =~ /[\x00-\x08\x0b-\x0d\x0e-\x1f\"\'\n]/ ) {
          $string =~ s/\\/\\\\/g;
          $string =~ s/"/\\"/g;
          $string =~ s/\n/\\n/g;
          $string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
          return qq|"$string"|;
      }
      if ( $string =~ /(?:^\W|\s|:\z)/ or $QUOTE{$string} ) {
          return "'$string'";
      }
      return $string;
  }
  
  sub _write_array {
      my ($self, $array, $indent, $seen) = @_;
      if ( $seen->{refaddr($array)}++ ) {
          die "YAML::Tiny does not support circular references";
      }
      my @lines  = ();
      foreach my $el ( @$array ) {
          my $line = ('  ' x $indent) . '-';
          my $type = ref $el;
          if ( ! $type ) {
              $line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
              push @lines, $line;
  
          } elsif ( $type eq 'ARRAY' ) {
              if ( @$el ) {
                  push @lines, $line;
                  push @lines, $self->_write_array( $el, $indent + 1, $seen );
              } else {
                  $line .= ' []';
                  push @lines, $line;
              }
  
          } elsif ( $type eq 'HASH' ) {
              if ( keys %$el ) {
                  push @lines, $line;
                  push @lines, $self->_write_hash( $el, $indent + 1, $seen );
              } else {
                  $line .= ' {}';
                  push @lines, $line;
              }
  
          } else {
              die "YAML::Tiny does not support $type references";
          }
      }
  
      @lines;
  }
  
  sub _write_hash {
      my ($self, $hash, $indent, $seen) = @_;
      if ( $seen->{refaddr($hash)}++ ) {
          die "YAML::Tiny does not support circular references";
      }
      my @lines  = ();
      foreach my $name ( sort keys %$hash ) {
          my $el   = $hash->{$name};
          my $line = ('  ' x $indent) . "$name:";
          my $type = ref $el;
          if ( ! $type ) {
              $line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
              push @lines, $line;
  
          } elsif ( $type eq 'ARRAY' ) {
              if ( @$el ) {
                  push @lines, $line;
                  push @lines, $self->_write_array( $el, $indent + 1, $seen );
              } else {
                  $line .= ' []';
                  push @lines, $line;
              }
  
          } elsif ( $type eq 'HASH' ) {
              if ( keys %$el ) {
                  push @lines, $line;
                  push @lines, $self->_write_hash( $el, $indent + 1, $seen );
              } else {
                  $line .= ' {}';
                  push @lines, $line;
              }
  
          } else {
              die "YAML::Tiny does not support $type references";
          }
      }
  
      @lines;
  }
  
  # Set error
  sub _error {
      $YAML::Tiny::errstr = $_[1];
      undef;
  }
  
  # Retrieve error
  sub errstr {
      $YAML::Tiny::errstr;
  }
  
  
  
  
  
  #####################################################################
  # YAML Compatibility
  
  sub Dump {
      YAML::Tiny->new(@_)->write_string;
  }
  
  sub Load {
      my $self = YAML::Tiny->read_string(@_);
      unless ( $self ) {
          Carp::croak("Failed to load YAML document from string");
      }
      if ( wantarray ) {
          return @$self;
      } else {
          # To match YAML.pm, return the last document
          return $self->[-1];
      }
  }
  
  BEGIN {
      *freeze = *Dump;
      *thaw   = *Load;
  }
  
  sub DumpFile {
      my $file = shift;
      YAML::Tiny->new(@_)->write($file);
  }
  
  sub LoadFile {
      my $self = YAML::Tiny->read($_[0]);
      unless ( $self ) {
          Carp::croak("Failed to load YAML document from '" . ($_[0] || '') . "'");
      }
      if ( wantarray ) {
          return @$self;
      } else {
          # Return only the last document to match YAML.pm,
          return $self->[-1];
      }
  }
  
  
  
  
  
  #####################################################################
  # Use Scalar::Util if possible, otherwise emulate it
  
  BEGIN {
      local $@;
      eval {
          require Scalar::Util;
      };
      my $v = eval("$Scalar::Util::VERSION") || 0;
      if ( $@ or $v < 1.18 ) {
          eval <<'END_PERL';
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { local $^W; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
      } else {
          *refaddr = *Scalar::Util::refaddr;
      }
  }
  
  1;
APP_GHAINSTALL_YAML

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use 5.006;
use strict;
use warnings;
use lib 'lib';

use App::GhaInstall;

exit( 'App::GhaInstall'->go( @ARGV ) );
